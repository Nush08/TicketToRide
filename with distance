//
//  TTR Movement.cpp
//  CPLEX 2
//
//  Created by Anushka Iyengar on 4/22/17.
//  Copyright Â© 2017 Anushka Iyengar. All rights reserved.
//

#include <stdio.h>
#include <limits.h>
#include <math.h>
# include<iostream>
using namespace std;


#define V 10
const int A=6;
//const int src=8; //reward node
int dist[V];

int max6(double a,double b,double c,double d,double e,double f){
    int maximum=0;
    int maximumab=0;
    int maximumcd=0;
    int maximumef=0;
    int outputab;
    int outputcd;
    int outputef;
    int output=0;
    
    //compare a and b
    if (a>b){
        maximumab=a;
        outputab=0;
    }
    else {
        maximumab=b;
        outputab=1;
    }
    //compare c and d
    if (c>d){
        maximumcd=c;
        outputcd=2;
    }
    else{
        maximumcd=d;
        outputcd=3;
    }
    //compare e and f
    if (e>f){
        maximumef=e;
        outputef=4;
    }
    else{
        maximumef=f;
        outputef=5;
    }
    //compare max of ab and cd
    if (maximumab>maximumcd){
        maximum=maximumab;
        output=outputab;
    }
    else{
        maximum=maximumcd;
        output=outputcd;
    }
    
    //find max of all
    if (maximum>maximumef){
        maximum=maximum;
        output=output;
    }
    else{
        maximum=maximumef;
        output=outputef;
    }
    
    //max action
    return output;
}


//Minimum Distance Function
int minDistance(int dist[], bool sptSet[])
{
    // Initialize min value
    int min = INT_MAX;
    int min_index=0;
    for (int v = 0; v < V; v++){
        if (sptSet[v] == false && dist[v] <= min){
            min = dist[v], min_index = v;
        }
    }
    return min_index;
}


//Dijkstra Function
void dijkstra(int graph[V][V],int src)
{
    // sptSet[i] will true if vertex i is included / in shortest
    // path tree or shortest distance from src to i is finalized
    bool sptSet[V];
    
    // Parent array to store shortest path tree
    int parent[V];
    
    // Initialize all distances as INFINITE and stpSet[] as false
    for (int i = 0; i < V; i++)
    {
        parent[src] = -1;
        dist[i] = INT_MAX;
        sptSet[i] = false;
    }
    
    // Distance of source vertex from itself is always 0
    dist[src] = 0;
    
    // Find shortest path for all vertices
    for (int count = 0; count < V-1; count++)
    {
        // Pick the minimum distance vertex from the set of
        // vertices not yet processed. u is always equal to src
        // in first iteration.
        int u = minDistance(dist, sptSet);
        
        // Mark the picked vertex as processed
        sptSet[u] = true;
        
        // Update dist value of the adjacent vertices of the
        // picked vertex.
        for (int v = 0; v < V; v++)
            
            // Update dist[v] only if is not in sptSet, there is
            // an edge from u to v, and total weight of path from
            // src to v through u is smaller than current value of
            // dist[v]
            if (!sptSet[v] && graph[u][v] &&
                dist[u] + graph[u][v] < dist[v])
            {
                parent[v]  = u;
                dist[v] = dist[u] + graph[u][v];
            }
    }
}//end dijkstra function


int main(){
    int reward[6];
    reward[0]=1;
    reward[1]=2;
    reward[2]=2;
    reward[3]=4;
    reward[4]=10;
    reward[5]=15;
    
    int totalCount=0;
    int totalIterations=10;
    
    
    for(int iteration=0;iteration<totalIterations;iteration++){
        int graph[V][V] = {
            {0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
            {0, 0, 4, 0, 0, 0, 0, 0, 2, 0},
            {0, 4, 0, 2, 0, 0, 0, 0, 1, 0},
            {0, 0, 2, 0, 3, 0, 4, 0, 0, 1},
            {0, 0, 0, 3, 0, 2, 4, 0, 0, 0},
            {0, 0, 0, 0, 2, 0, 5, 0, 0, 0},
            {0, 0, 0, 4, 0, 5, 0, 2, 0, 0},
            {0, 0, 0, 0, 0, 0, 2, 0, 6, 5},
            {0, 2, 1, 0, 0, 0, 0, 6, 0, 3},
            {0, 0, 0, 1, 0, 0, 0, 5, 3, 0}
        }; //end graph
        
        int moves[V][A]={
            {0,	0,	0,	0,	0,	0},
            {0,	8,	0,	2,	0,	0},
            {8,	3,	0,	1,	0,	0},
            {9,	2,	4,	6,	0,	0},
            {0,	5,	3,	6,	0,	0},
            {0,	4,	0,	0,	6,	0},
            {0,	7,	0,	3,	5,	0},
            {0,	6,	0,	0,	9,	8},
            {2,	1,	9,	0,	0,	7},
            {3,	0,	8,	0,	7,	0},
        };
        // int start=(rand()%8)+1;
        int startNode=rand()%9;
        
        int nextNode;
        int tempNextNode;
        int rewardNode=8;
        dijkstra(graph,rewardNode);
        int T=15;
        int path[T];
        path[0]=startNode;
        int tempValue[V][V];
        int totalValue=0;
        int trainsLeft=45;
        
        int optAction[startNode];
        int opStartNode=(rand()%9);
        int opPath[T];
        opPath[0]=opStartNode;
        int opNextNode;
        int opAction;
        int opTotalValue=0;
        //basis function, Q[distance to reward][distancet to opponent]=w*1/d1^2+w2*1/d2^2
        double w1;
        double w2;
        int d1;
        int d2;
        int totalTurns=0;
        
        for (int t=1;t<T;t++){
            dijkstra(graph,rewardNode);
            d1=dist[startNode];
            if (abs(d1)>1000){
                d1=-50;
            }
            dijkstra(graph,opStartNode);
            d2=dist[startNode];
            if (abs(d2)>1000){
                d2=-50;
            }
            cout<<"distance to reward:"<<d1<<" distance to op:"<<d2<<"\n";
            for (int a=0;a<A;a++){
                tempNextNode=moves[startNode][a];
                if(tempNextNode==0){
                    tempValue[startNode][a]=0;
                    
                    //cout<<"I cannot move from "<<startNode<<" to "<<tempNextNode<<" with action "<<a<<" so this move has a value of "<<tempValue[startNode][a]<<"\n";
                }
                else{
                    tempValue[startNode][a]=pow((a+1),2);
                    
                    //cout<<"I can move from "<<startNode<<" to "<<tempNextNode<<" with action "<<a<<" so this move has a value of "<<tempValue[startNode][a]<<"\n";
                    
                }
            }//end of possible action
            optAction[startNode]=max6(tempValue[startNode][0],tempValue[startNode][1],tempValue[startNode][2],tempValue[startNode][3],tempValue[startNode][4],tempValue[startNode][5]);
            //cout<<"optaction output:"<<optAction[startNode]<<"\n";
            nextNode=moves[startNode][optAction[startNode]];
            cout<<"the optimal action is "<<optAction[startNode]<<" taking us from "<<startNode<<" to "<<nextNode<<"\n";
            graph[startNode][nextNode]=0;
            graph[nextNode][startNode]=0;
            moves[startNode][optAction[startNode]]=0;
            moves[nextNode][optAction[startNode]]=0;
            totalValue=totalValue+reward[optAction[startNode]];
            trainsLeft=trainsLeft-optAction[startNode]-1;
            path[t]=nextNode;
            startNode=nextNode;
            cout<<"trains left"<<trainsLeft<<"\n";
            //Opponent
            opAction=rand()%5;
            opNextNode=moves[opStartNode][opAction];
            int dice=0;
            while(opNextNode==0){
                opAction=rand()%5;
                opNextNode=moves[opStartNode][opAction];
                dice=dice+1;
                if(dice==10){
                    opAction=7;
                    opNextNode=rand()%9;
                }
            }
            if(opNextNode==0){
                
                cout<<"opponent doesn't move\n";
                opStartNode=opStartNode;
            }
            else{
                cout<<"Opponent goes from "<<opStartNode<<" to "<<opNextNode<<" with action "<<opAction<<"\n";
                if(opAction==7){
                    opStartNode=opNextNode;
                    opTotalValue=opTotalValue+7;
                }
                else{
                    graph[opStartNode][opNextNode]=0;
                    graph[opNextNode][opStartNode]=0;
                    moves[opStartNode][opAction]=0;
                    moves[opNextNode][opAction]=0;
                    opStartNode=opNextNode;
                    opTotalValue=opTotalValue+reward[opAction];
                }
            }
            cout<<"The score is You:"<<totalValue<<" Op:"<<opTotalValue<<"\n";
            //EndGame before time is called
            if (trainsLeft<2){
                t=T;
                //totalTurns=t;
            }
            else{
                t=t;
            }
            totalTurns=totalTurns+1;
        }//time
        if(totalValue<opTotalValue){
            cout<<"You Lose! You:"<<totalValue<<" Op:"<<opTotalValue<<" in "<<totalTurns<<" turns \n\n\n";
        }
        else{
            cout<<"You Win! You:"<<totalValue<<" Op:"<<opTotalValue<<" in "<<totalTurns<<" turns \n\n\n";
            totalCount=totalCount+1;
        }
    }
    cout<<"You've won "<<totalCount<<" out of "<<totalIterations<<" games!\n";
}//end main

