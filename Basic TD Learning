//  Created by Anushka Iyengar on 4/18/17.
//  Copyright Â© 2017 Anushka Iyengar. All rights reserved.
//
#include <stdio.h>
#include <limits.h>
#include <math.h>
# include<iostream>
using namespace std;

// Number of vertices in the graph
#define V 9
const int D=45;//# of left s1
const int E=45;//# of distance s2
const int F=45;//# of trains youve place s3
const int G=45;//# of trains op placed s4
const int H=V; //node you are on s5
const int C=2; //if ticket complete
const int A=6; //#of actions s6

//Value of having D trains left, being E distance from reward, the number of trains youve placed, the number of trains your opponents plaed, your current node, if the ticket is complet and what action you take
double Q[D][E][F][G][H][C][A];

int max(double a,double b,double c,double d,double e,double f){
    int maximum;
    int maximumab=0;
    int maximumcd=0;
    int maximumef=0;
    
    //compare a and b
    if (a>b){
        maximumab=0;
    }
    else {
        maximumab=1;
    }
    //compare c and d
    if (c>d){
        maximumcd=2;
    }
    else{
        maximumcd=3;
    }
    //compare e and f
    if (e>f){
        maximumef=4;
    }
    else{
        maximumef=5;
    }
    //compare max of ab and cd
    if (maximumab>maximumcd){
        maximum=maximumab;
    }
    else{
        maximum=maximumcd;
    }
    
    //find max of all
    if (maximum>maximumef){
        maximum=maximum;
    }
    else{
        maximum=maximumef;
    }
    
    //max action
    return maximum;
}

int main(){
    
    //int G=100; //distance
    
    double w1=1;
    double w2=1;
    double w3=1;
    double w4=1;
    double w5=1;
    double w6=1;
    double w7=50;
    double S1;
    double S2;
    double S3;
    double S4;
    double S5;
    double S6;
    double S7;
    double total;
    
    double alpha;
    alpha=0.5;
    
    int graph[V][V] = {
     {0, 4, 0, 0, 0, 0, 0, 8, 0},
     {4, 0, 8, 0, 0, 0, 0, 11, 0},
     {0, 8, 0, 7, 0, 4, 0, 0, 2},
     {0, 0, 7, 0, 9, 14, 0, 0, 0},
     {0, 0, 0, 9, 0, 10, 0, 0, 0},
     {0, 0, 4, 0, 10, 0, 2, 0, 0},
     {0, 0, 0, 14, 0, 2, 0, 1, 6},
     {8, 11, 0, 0, 0, 0, 1, 0, 7},
     {0, 0, 2, 0, 0, 0, 6, 7, 0}
     }; //end graph
    
    /**
     for (int s1=0;s1<D;s1++){
     cout<<"s1:"<<s1<<"\n";
     }
     */
    
    int reward[6];
    reward[0]=1;
    reward[1]=2;
    reward[2]=2;
    reward[3]=4;
    reward[4]=10;
    reward[5]=15;
    
    //Initialize Values
    for (int s1=0;s1<45;s1++){
        //cout<<"\n ITERATION:"<<s1<<"\n";
        
        for(int s2=0;s2<E;s2++){
            //cout<<"s1:"<<s1<<"\n";
            
            for(int s3=0;s3<F;s3++){
                //cout<<"s1:"<<s1<<"\n";
                
                for (int s4=0;s4<G;s4++){
                    //cout<<"s1:"<<s1<<"\n";
                    
                    for (int s5=0;s5<H;s5++){
                        //cout<<"s1:"<<s1<<"\n";
                        
                        for(int s6=0;s6<A;s6++){
                            for(int s7=0;s7<C;s7++){
                                //cout<<"s1:"<<s1<<"\n";
                                S1=s1*w1;
                                //cout<<"s1:"<<S1<<"s1:"<<s2<<"s1:"<<s3<<"s1:"<<s4<<"s1:"<<s5<<"s1:"<<s6<<"\n";
                                S2=s2*w2;
                                S3=s3*w3;
                                S4=s4*w4;
                                S5=s5*w5;
                                S6=s6*w6;
                                S7=s7*w7;
                                total=S1+S2+S3+S4+S5+S6+S7;
                                //cout<<"Total:"<<total<<"\n";
                                Q[s1][s2][s3][s4][s5][s7][s6]=total;
                                //Q[s1][s2][s3][s4][s5][s6]=1;
                                //cout <<Q[s1][s2][s3][s4][s5][s6]<<"-";
                            }
                        }//end s6
                        
                    }//end s5
                }//end s4
            } //end s3
        }//end s2
        
        //cout<<"\n ITERATION:"<<s1<<"\n";
    }//end s1
    //cout<<"\n ITERATION:"<<s1<<"\n";
    cout<<Q[0][2][2][2][3][0][2]<<"\n";
    cout<<Q[0][2][2][2][3][1][2]<<"\n";

    cout<<"Hello World\n";
    
    //Updating
    int optA[V];
    double Value[V][A];
    double difference;
    int startNode=rand()%9;
    int trainsLeft=45;
    int dist[V];
    //run dijkstra once and record the min distance from every node to reward node, save in array
    //how
    int rewardNode=0;
    for (int t=0;t<10;t++){
        cout<<"We are at node:"<<startNode<<"\n";
        cout<<"w1:"<<w1<<" w2:"<<w2<<" w3:"<<w3<<" w4:"<<w4<<" w5:"<<w5<<" w6:"<<w6<<" w7:"<<w7<<"\n";
        //Value of having D trains left, being E distance from reward, the number of trains youve placed, the number of trains your opponents plaed, your current node, if the ticket is complet and what action you take
        //find max approximate value of future state
        for (int a=0;a<A;a++){
            //find approximate value of being in future state for every action
            if((startNode-a)==rewardNode){
            Value[startNode-a][a]=Q[trainsLeft-a][dist[startNode-a]][45-trainsLeft-a-1][0][startNode-a][1][a];
            }
        }
        optA[startNode]=max(Value[startNode][0],Value[startNode][1],Value[startNode][2],Value[startNode][3],Value[startNode][4],Value[startNode][5]);
        
        //reward+alpha*Q(s',a')-Q(s,a)
        difference=reward[optA[startNode]]+alpha*Q[trainsLeft-optA[startNode]][dist[startNode-optA[startNode]]][45-trainsLeft-optA[startNode]][0][startNode-optA[startNode]][1][optA[startNode]]-Q[trainsLeft][dist[startNode]][45-trainsLeft][0][startNode][0][optA[startNode]];
        //update coefficients
        w1=w1+alpha*difference*(trainsLeft-optA[startNode]);
        w2=w2+alpha*difference*(dist[startNode-optA[startNode]]);
        w3=w3+alpha*difference*(45-trainsLeft-optA[startNode]);
        w4=w4+alpha*difference*0;
        w5=w5+alpha*difference*(startNode-optA[startNode]);
        w6=w6+alpha*difference*1;
        w7=w7+alpha*difference*optA[startNode];
        trainsLeft=trainsLeft-(optA[startNode]-1);
        startNode=startNode-optA[startNode];
        
    }
    
    
}//end main
